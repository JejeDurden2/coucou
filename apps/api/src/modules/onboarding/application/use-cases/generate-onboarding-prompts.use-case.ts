import { Inject, Injectable } from '@nestjs/common';
import { Plan, PLAN_LIMITS } from '@coucou-ia/shared';

import { ForbiddenError, NotFoundError, Result, withSpan } from '../../../../common';
import { LoggerService } from '../../../../common/logger';
import {
  PROJECT_REPOSITORY,
  type ProjectRepository,
} from '../../../project/domain/repositories/project.repository';
import {
  PROMPT_REPOSITORY,
  type PromptRepository,
} from '../../../prompt/domain/repositories/prompt.repository';
import type { PromptResponseDto } from '../../../prompt/application/dto/prompt.dto';
import {
  BRAND_ANALYZER,
  type BrandAnalyzerPort,
  type BrandContext,
} from '../ports/brand-analyzer.port';
import {
  BrandContextExtractionError,
  PromptGenerationError,
} from '../../domain/errors/onboarding.errors';

type GenerateOnboardingPromptsError =
  | NotFoundError
  | ForbiddenError
  | BrandContextExtractionError
  | PromptGenerationError;

@Injectable()
export class GenerateOnboardingPromptsUseCase {
  constructor(
    @Inject(PROJECT_REPOSITORY)
    private readonly projectRepository: ProjectRepository,
    @Inject(PROMPT_REPOSITORY)
    private readonly promptRepository: PromptRepository,
    @Inject(BRAND_ANALYZER)
    private readonly brandAnalyzer: BrandAnalyzerPort,
    private readonly logger: LoggerService,
  ) {
    this.logger.setContext(GenerateOnboardingPromptsUseCase.name);
  }

  async execute(
    projectId: string,
    userId: string,
    plan: Plan,
  ): Promise<Result<PromptResponseDto[], GenerateOnboardingPromptsError>> {
    return withSpan(
      'onboarding-module',
      'GenerateOnboardingPromptsUseCase.execute',
      { 'onboarding.projectId': projectId, 'onboarding.userId': userId, 'onboarding.plan': plan },
      async () => {
        // 1. Verify project exists and belongs to user
        const project = await this.projectRepository.findById(projectId);
        if (!project) {
          return Result.err(new NotFoundError('Project', projectId));
        }
        if (!project.belongsTo(userId)) {
          return Result.err(new ForbiddenError('You do not have access to this project'));
        }

        // 2. Extract brand context via web search
        let brandContext: BrandContext;
        try {
          brandContext = await this.brandAnalyzer.extractContext(project.domain, project.brandName);
        } catch (error) {
          this.logger.warn('Brand context extraction failed', {
            domain: project.domain,
            error: error instanceof Error ? error.message : 'Unknown error',
          });
          return Result.err(new BrandContextExtractionError(project.domain));
        }

        // 3. Save brand context to project
        const brandContextWithTimestamp = {
          ...brandContext,
          extractedAt: new Date().toISOString(),
        };
        await this.projectRepository.updateBrandContext(projectId, brandContextWithTimestamp);

        // 4. Generate prompts based on plan limits
        const promptCount = PLAN_LIMITS[plan].autoGeneratedPrompts;
        let generatedPrompts;
        try {
          generatedPrompts = await this.brandAnalyzer.generatePrompts(
            brandContext,
            project.brandName,
            promptCount,
          );
        } catch (error) {
          this.logger.warn('Prompt generation failed', {
            error: error instanceof Error ? error.message : 'Unknown error',
          });
          return Result.err(
            new PromptGenerationError(error instanceof Error ? error.message : 'Unknown error'),
          );
        }

        // 5. Create prompts in database
        const createdPrompts: PromptResponseDto[] = [];
        for (const generatedPrompt of generatedPrompts) {
          const prompt = await this.promptRepository.create({
            projectId,
            content: generatedPrompt.content,
            category: generatedPrompt.category,
          });
          createdPrompts.push({
            id: prompt.id,
            projectId: prompt.projectId,
            content: prompt.content,
            category: prompt.category,
            isActive: prompt.isActive,
            lastScannedAt: prompt.lastScannedAt,
            createdAt: prompt.createdAt,
            updatedAt: prompt.updatedAt,
          });
        }

        this.logger.info('Successfully generated prompts', {
          projectId,
          promptsCount: createdPrompts.length,
        });

        return Result.ok(createdPrompts);
      },
    );
  }
}
