generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ============================================
// ENUMS
// ============================================

enum Plan {
  FREE
  SOLO
  PRO
}

enum SubscriptionStatus {
  ACTIVE
  CANCELED
  PAST_DUE
  TRIALING
}

enum LLMProvider {
  OPENAI
  ANTHROPIC
}

enum ScanJobStatus {
  PENDING
  PROCESSING
  COMPLETED
  PARTIAL
  FAILED
}

enum ConsentType {
  TERMS_OF_SERVICE
  PRIVACY_POLICY
}

enum ConsentAction {
  ACCEPTED
  WITHDRAWN
}

// ============================================
// MODELS
// ============================================

model User {
  id               String   @id @default(cuid())
  email            String   @unique
  name             String
  password         String?
  googleId         String?  @unique @map("google_id")
  avatarUrl        String?  @map("avatar_url")
  plan             Plan     @default(FREE)
  stripeCustomerId String?  @unique @map("stripe_customer_id")

  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime  @updatedAt @map("updated_at")
  deletedAt DateTime? @map("deleted_at")

  projects            Project[]
  subscription        Subscription?
  passwordResetTokens PasswordResetToken[]
  consentLogs         ConsentLog[]

  @@map("users")
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  userId    String   @map("user_id")
  token     String   @unique
  expiresAt DateTime @map("expires_at")
  usedAt    DateTime? @map("used_at")

  createdAt DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([userId])
  @@map("password_reset_tokens")
}

model Subscription {
  id                   String             @id @default(cuid())
  userId               String             @unique @map("user_id")
  stripeSubscriptionId String             @unique @map("stripe_subscription_id")
  status               SubscriptionStatus
  plan                 Plan
  currentPeriodStart   DateTime           @map("current_period_start")
  currentPeriodEnd     DateTime           @map("current_period_end")
  cancelAtPeriodEnd    Boolean            @default(false) @map("cancel_at_period_end")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("subscriptions")
}

model Project {
  id            String    @id @default(cuid())
  userId        String    @map("user_id")
  name          String
  brandName     String    @map("brand_name")
  brandVariants String[]  @map("brand_variants")
  domain        String
  brandContext  Json?     @map("brand_context")
  lastScannedAt DateTime? @map("last_scanned_at")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  prompts  Prompt[]
  scanJobs ScanJob[]

  @@index([userId])
  @@map("projects")
}

model Prompt {
  id            String    @id @default(cuid())
  projectId     String    @map("project_id")
  content       String
  category      String?
  isActive      Boolean   @default(true) @map("is_active")
  lastScannedAt DateTime? @map("last_scanned_at")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  project  Project   @relation(fields: [projectId], references: [id], onDelete: Cascade)
  scans    Scan[]
  scanJobs ScanJob[]

  @@index([projectId])
  @@map("prompts")
}

model Scan {
  id         String   @id @default(cuid())
  promptId   String   @map("prompt_id")
  executedAt DateTime @default(now()) @map("executed_at")

  // Results for each LLM provider stored as JSON
  // Structure: { provider: LLMProvider, model: string, rawResponse: string,
  //              isCited: boolean, citationContext: string?, position: number?,
  //              competitors: string[], latencyMs: number }[]
  results Json

  createdAt DateTime @default(now()) @map("created_at")

  prompt Prompt @relation(fields: [promptId], references: [id], onDelete: Cascade)

  @@index([promptId, executedAt])
  @@map("scans")
}

model ScanJob {
  id               String        @id @default(cuid())
  projectId        String        @map("project_id")
  userId           String        @map("user_id")
  promptId         String?       @map("prompt_id") // null = project scan, set = single prompt scan
  status           ScanJobStatus @default(PENDING)
  totalPrompts     Int           @map("total_prompts")
  processedPrompts Int           @default(0) @map("processed_prompts")
  successCount     Int           @default(0) @map("success_count")
  failureCount     Int           @default(0) @map("failure_count")
  errorMessage     String?       @map("error_message")
  startedAt        DateTime?     @map("started_at")
  completedAt      DateTime?     @map("completed_at")
  createdAt        DateTime      @default(now()) @map("created_at")

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  prompt  Prompt? @relation(fields: [promptId], references: [id], onDelete: Cascade)

  @@index([projectId, createdAt])
  @@index([userId, status])
  @@index([promptId])
  @@map("scan_jobs")
}

model ConsentLog {
  id        String        @id @default(cuid())
  userId    String        @map("user_id")
  type      ConsentType
  action    ConsentAction
  version   String
  ipAddress String?       @map("ip_address")
  userAgent String?       @map("user_agent")

  createdAt DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, type])
  @@map("consent_logs")
}
